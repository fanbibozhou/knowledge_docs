# 03-数据结构

我们上一章学习的字符串就是一种序列。关于字符串里面很多操作，在这一章中仍然会 用到，大家一定会感觉非常熟悉。  

本章内容，我们必须非常熟悉。无论是在学习还是工作中，序列都是每天都会用到的技 术，可以非常方便的帮助我们进行数据存储的操作。 

## 1、列表list

Python 支持多种 *复合* 数据类型，可将不同值组合在一起。最常用的 *列表* ，是用方括号标注，逗号分隔的一组值。*列表* 可以包含不同类型的元素，但一般情况下，各个元素的类型相同：

### 1.1 列表介绍

**列表：用于存储任意数目、任意类型的数据集合。**  

列表是内置`可变序列`，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式：  ` a = [10,20,30,30]  `

其中，10,20,30,30 这些称为：列表 a 的元素。  

列表中的元素可以各不相同，可以是任意类型。比如：  ` a = [10,20,'abc',True]  `

列表对象的常用方法汇总如下，方便大家学习和查阅。  

| **方法**             | **要点**     | **描述**                                                     |
| -------------------- | ------------ | ------------------------------------------------------------ |
| list.append(x)       | 增加元素     | 将元素 x 增加到列表 list 尾部                                |
| list.extend(aList)   | 增加元素     | 将列表 alist 所有元素加到列表 list 尾部                      |
| list.insert(index,x) | 增加元素     | 在列表 list 指定位置 index 处插入元素 x                      |
| list.remove(x)       | 删除元素     | 在列表 list 中删除首次出现的指定元素 x                       |
| list.pop([index])    | 删除元素     | 删除并返回列表 list 指定为止 index 处的元素，默认是 最后一个元 |
| list.clear()         | 删除所有元素 | 删除列表所有元素，并不是删除列表对象                         |
| list.index(x)        | 访问元素     | 返回第一个 x 的索引位置，若不存在 x 元素抛出异常             |
| list.count(x)        | 计数         | 返回指定元素 x 在列表 list 中出现的次数                      |
| len(list)            | 列表长度     | 返回列表中包含元素的个数                                     |
| list.reverse()       | 翻转列表     | 所有元素原地翻转                                             |
| list.sort()          | 排序         | 所有元素原地排序                                             |
| list.copy()          | 浅拷贝       | 返回列表对象的浅拷贝                                         |

 Python 的列表大小可变，根据需要随时增加或缩小。  

 字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样。  

### 1.2 列表的创建

- 基本语法`[]`创建

```python
>>> squares = [1, 4, 9, 16, 25]   # 通过[]创建列表
>>> squares
[1, 4, 9, 16, 25]
>>> squares01 = []  # 空列表
```

- 通过内置函数`list()`创建

```python
 >>> a = list() #创建一个空的列表对象 
>>> a = list(range(10)) 
>>> a 
[0, 1, 2, 3, 3, 5, 6, 7, 8, 9] 
>>> a = list("hello,world")
>>> a
['h', 'e', 'l', 'l', 'o', ',', 'w', 'o', 'r', 'l', 'd']
```

- `range()`创建整数列表

`range()`可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为：  ` range([start,] end [,step])  `

- `start` 参数：可选，表示起始数字。默认是 0 

- `end` 参数：必选，表示结尾数字。 

- `step` 参数：可选，表示步长，默认为 1  

python3 中 `range()`返回的是一个 range 对象，而不是列表。我们需要通过 `list()`方法将其 转换成列表对象。  

**典型示例如下：**  

```python
>>> list(range(3,15,2))
[3, 5, 7, 9, 11, 13]
>>> list(range(15,3,-1))
[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]
>>> list(range(3,-10,-1))
[3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9] 
```

- 通过列表推导式创建

使用列表推导式可以非常方便的创建列表，在开发中经常使用。但是，由于涉及到 for 循环 和 if 语句。在此，仅做基本介绍。在我们控制语句后面，会详细讲解更多列表推导式的细 节。

```python
>>> a = [x*2 for x in range(5)] #循环创建多个元素
>>> a
[0, 2, 4, 6, 8]
>>> a = [x*2 for x in range(100) if x%9==0] #通过 if 过滤元素
>>> a
[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]
```

### 1.3 列表元素的增加和删除

当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素或删除元素，这会大大提高列表的操作效率。

#### 1.3.1 列表元素的增加

- **`list.append(x)`方法：**
  - 向列表的末尾添加一个元素，原地修改列表对象，相当于 `a[len(a):] = [x]`，是真正的列表尾部添加新的元素，速度最快，推荐使用。  
  - `x`参数为添加的列表元素

```python
>>> a = [20,40]
>>> a.append(80)
>>> a
[20, 40, 80]
```

- **`+`运算符操作：**并不是真正的尾部添加元素，而是创建新的列表对象；将原列表的元素和新列表的元素依次 复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。  

```python
>>> a = [20,40]
>>> id(a)
46016072
>>> a = a+[50]
>>> id(a)
46015432
```

通过如上测试，我们发现变量 a 的地址发生了变化。也就是创建了新的列表对象。

- **`list.extend(iterable)`方法**：
  - 将另一个列表的元素添加到当前列表的末尾，属于原地操作，不创建新的列表对象。  
  - `iterable`参数可迭代对象，也就是可以是列表、字符串、元组等序列
  - 用可迭代对象的元素扩展列表。相当于 `a[len(a):] = iterable` 

```python
>>> a = [20,40]
>>> id(a)
46016072
>>> a.extend([50,60])
>>> id(a)
46016072
>>> a
[20,40,50,60]
```

-  **`list.insert(i, x)`插入元素**
  - 在指定位置插入元素。第一个参数是插入元素的索引，
  - `a.insert(0, x)` 在列表开头插入元素
  - `a.insert(len(a), x)` 等同于 `a.append(x)` 。
  - 这样会让插入位置后面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。

```python
>>> a = [10,20,30]
>>> a.insert(2,100)
>>> a
[10, 20,100, 30]
```

- **乘法扩展**：使用乘法扩展列表，生成一个新列表，新列表元素是原列表元素的多次重复。  

```python
>>> a = [10,20,30]
>>> a * 3   # 适用于乘法操作的，还有：字符串、元组。例如：
[10, 20, 30, 10, 20, 30, 10, 20, 30]
```

#### 1.3.2 列表的删除

- **`del语句`删除：**删除指定索引位置的元素或整个列表
  - del后面跟索引删除指定索引位置的元素
  - del后面跟列表名称，直接删除整个列表
  - del结合[start:end]删除指定范围的数据，

```python
>>> a = [100,200,888,300,400]
>>> del a[2]   # 删除列表指定位置的元素
>>> a
[100,200,300,400]
>>> del a  # 删除整个列表
>>> a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined   # 列表被删除，所以报未定义错误
>>> a = [100,200,888,300,400]
>>> del a[1:3]   # 删除索引1和2的元素，不包含3
>>> a
[100, 300, 400]
>>> del a[:]   # 清空列表
>>> a
[]
```

- **`list.pop([i])`方法：**删除并返回指定索引位置的元素（默认为最后一个元素）
  - 未指定位置时，`a.pop()` 删除并返回列表的最后一个元素。（常用）
  - 书写存在的下标，删除对应下标位置的数据并返回：返回的是删除的数据

> 方法签名中 *i* 两边的方括号表示该参数是可选的，不是要求输入方括号。这种表示法常见于 Python 参考库

```python
>>> a = [10,20,30,40,50]
>>> a.pop()
50
>>> a
[10, 20, 30, 40]
>>> a.pop(1)
20
>>> a
[10, 30, 40]
```

- **`list.remove()`方法（根据数据值删除）**：从列表中删除第一个值为 *x* 的元素。
  - 返回：None
  - 注意：未找到指定元素时，触发 [`ValueError`](https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError) 异常。

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a.remove(20)   # 删除第一个元素为20的数据
>>> a
[10, 30, 40, 50, 20, 30, 20, 30]
>>> a.remove(100)    # 删除不存在的元素会报错
Traceback (most recent call last):
File "<pyshell#208>", line 1, in <module>
a.remove(100)
ValueError: list.remove(x): x not in list
```

- **`list.clear()`方法：**删除列表里的所有元素，相当于 `del a[:]`

```python
>>> a = [100,200,888,300,400]
>>> a
[100, 200, 888, 300, 400]
>>> a.clear()
>>> a
[]
```

### 1.4 列表的元素访问和计数

- **通过索引直接访问元素**：我们可以通过索引直接访问元素。索引的区间在`[0, 列表长度-1]`这个范围。超过这个范围则 会抛出异常。  

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a[2]
30
>>> a[10]
Traceback (most recent call last):
File "<pyshell#211>", line 1, in <module>
a[10]
IndexError: list index out of range
```

- `list.index(x[, start[, end]])`:
  - 返回列表中第一个值为 *x* 的元素的零基索引。
  - 未找到指定元素时，触发 [`ValueError`](https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError) 异常。
  - 可选参数 *start* 和 *end* 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 *start* 参数。

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a.index(20)
1
>>> a.index(20,3)
5
>>> a.index(20,3) # 添加start参数，从索引位置 3 开始往后搜索的第一个 20
5
>>> a.index(30,5,7) # 添加start和end参数从索引位置 5 到 7 这个区间，第一次出现 30 元素的位置
6   # 返回的索引是相对于整个序列计算的，并不是范围的
```

- `count(x):`返回列表中元素 *x* 出现的次数。

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a.count(20)
3
```

- **`len(iterable)`返回列表长度**
  - len()方法可适用于字符串、元组、列表等序列

```python
# len()返回列表长度，即列表中包含元素的个数。
>>> a = [10,20,30]
>>> len(a)
3
```

- **成员资格判断**

判断列表中是否存在指定的元素，我们可以使用 `count()`方法，返回 0 则表示不存在，返回 大于 0 则表示存在。但是，一般我们会使用更加简洁的 `in` 关键字来判断，直接返回 `True` 或 `False`。  

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> 20 in a
True
>>> 100 not in a
True
>>> 30 not in a
False
```

### 1.5 切片操作

与前面字符串一样，列表的切片操作和字符串类似。 切片是 Python 序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下： 

>  切片 slice 操作可以让我们快速提取子列表或修改。标准格式为： 
>
> ```
>   [起始偏移量 start:终止偏移量 end[:步长 step]  
> ```
>
>  注：当步长省略时顺便可以省略第二个冒号 

**典型操作(三个量为正数的情况)如下：**  

| **操作和说明**                                       | **示例**                         | **结果**     |
| ---------------------------------------------------- | -------------------------------- | ------------ |
| [:] 提取整个列表                                     | `[10,20,30][:]`                  | [10,20,30]   |
| [start:]从 start 索引开始到 结尾                     | `[10,20,30][1:]`                 | [20,30]      |
| [:end]从头开始知道 end-1                             | `[10,20,30][:2]`                 | [10,20]      |
| [start:end]从 start 到 end-1                         | `[10,20,30,30][1:3]`             | [20,30]      |
| [start:end:step] 从 start 提 取到 end-1，步长是 step | `[10,20,30,30,50,60,70][1:6: 2]` | [20, 30, 60] |

 **其他操作（三个量为负数）的情况：**  

| **示例**                        | **说明**                            | **结果**                     |
| ------------------------------- | ----------------------------------- | ---------------------------- |
| `[10,20,30,30,50,60,70][-3:]`   | 倒数三个                            | [50,60,70]                   |
| `[10,20,30,30,50,60,70][-5:-3]` | 倒数第五个到倒数 第三个(包头不包尾) | [30,30]                      |
| `[10,20,30,30,50,60,70][::-1]`  | 步长为负，从右到左 反向提取         | [70, 60, 50, 30, 30, 20, 10] |

 切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始 偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成”长度-1”。例如： 

```python
>>>[10,20,30,30][1:30]
[20, 30, 30] 
```

我们发现正常输出了结果，没有报错 

### 1.6 列表的拷贝

-  **复制列表所有的元素到新列表对象**  

```python
# 如下代码实现列表元素的复制了吗？
list1 = [30,40,50]
list2 = list1
```

上面的代码并没有实现列表的复制，只是将list2也赋予了列表对象的地址。也就是说 list2 和 list2 持有地址值是相同的，列表对象本身的元素并没有复制。  

我们可以通过如下简单方式，实现列表元素内容的复制：

> 将列表中的数据复制一份，给到一个新的列表
> 使用场景：有一个列表，需要修改操作列表中的数据，同时还要备份列表中的数据，需要和源数据进行对比，即原数据不能改，有以下几种方法：
> 1.使用切片
> 变量 = 列表[:]
> 2.使用copy方法
> 变量 = 列表.copy()
>
> 3.创建一个空列表，然后采用拼接的方式
>
> ```python
> list1 = [30,40,50]
> list2 = [] + list
> ```

### 1.7 列表排序

- **修改原列表，不建新列表的排序**

```python
>>> a = [20,10,30,40]
>>> id(a)
46017416
>>> a.sort() #默认是升序排列
>>> a
[10, 20, 30, 40]
>>> a = [10,20,30,40]
>>> a.sort(reverse=True) #降序排列
>>> a
[40, 30, 20, 10]
>>> import random
>>> random.shuffle(a) #打乱顺序
>>> a
[20, 40, 30, 10]
```

- **建立新列表的排序**

我们也可以通过内置函数 sorted()进行排序，这个方法返回新列表，不对原列表做修改。

```python
>>> a = [20,10,30,40]
>>> id(a)
46016008
>>> a = sorted(a) #默认升序
>>> a
[10, 20, 30, 40]
>>> id(a)
45907848
>>> a = [20,10,30,40]
>>> id(a)
45840584
>>> b = sorted(a)
>>> b
[10, 20, 30, 40]
>>> id(a)
45840584
>>> id(b)
46016072
>>> c = sorted(a,reverse=True) #降序
>>> c
[40, 30, 20, 10]
```

通过上面操作，我们可以看出，生成的列表对象 b 和 c 都是完全新的列表对象  

-  **reversed()返回迭代器**  

内置函数 reversed()也支持进行逆序排列，与列表对象 reverse()方法不同的是，内置函数 reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。 

```python
>>> a = [20,10,30,40]
>>> c = reversed(a)
>>> c
<list_reverseiterator object at 0x0000000002BCCEB8>
>>> list(c)
[40, 30, 10, 20]
>>> list(c)
[]
```

我们打印输出 `c` 发现提示是：`list_reverseiterator`。也就是一个迭代对象。同时，我们使用 `list(c)`进行输出，发现只能使用一次。第一次输出了元素，第二次为空。那是因为迭代对象 在第一次时已经遍历结束了，第二次不能再使用。  

> 注：关于迭代对象的使用，后续章节会进行详细讲解

### 1.8 列表相关的其他内置函数汇总

-  **max 和 min**

```python
# 用于返回列表中最大和最小值。
>>> a = [3,10,20,15,9]
>>> max(a)
20
>>> min(a)
3
```

- **sum**  

```python
# 对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。
>>> a = [3,10,20,15,9]
>>> sum(a)
57
```

### 1.9  多维列表

-  **二维列表**  

一维列表可以帮助我们存储一维、线性的数据。 二维列表可以帮助我们存储二维、表格的数据。例如下表的数据：  

| 姓名   | 年龄 | 薪资  | 城市 |
| ------ | ---- | ----- | ---- |
| 高小一 | 18   | 30000 | 北京 |
| 高小二 | 19   | 20000 | 上海 |
| 高小五 | 20   | 10000 | 深圳 |

```python
a = [
	["高小一",18,30000,"北京"], 
	["高小二",19,20000,"上海"], 
	["高小一",20,10000,"深圳"], 
]
>>> print(a[1][0],a[1][1],a[1][2])
高小二 19 20000
```

 内存结构图：  

![img](https://gitee.com/iscn/md_images/raw/master/python/%E5%A4%9A%E7%BB%B4%E5%88%97%E8%A1%A8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png)

 **嵌套循环打印二维列表所有的数据（由于没有学循环，照着敲一遍即可）：**  

```python
a = [
["高小一",18,30000,"北京"], ["高小二",19,20000,"上海"], ["高小一",20,10000,"深圳"], ]
for m in range(3):
	for n in range(4):
		print(a[m][n],end="\t")
	print() #打印完一行，换行
```

## 2、元组 tuple  

列表属于可变序列，可以任意修改列表中的元素。**元组属于不可变序列**，不能修改元组中的元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。  

因此，我们只需要学习元组的创建，元组中元素的访问和计数即可。元组支持如下操作：  

- 索引访问 

- 切片操作 

- 连接操作 

- 成员关系操作 

- 比较运算操作 

- 计数：元组长度 `len()`、最大值 `max()`、最小值 min()、求和 `sum()`等。  

### 2.1  元组的创建  

- **通过()创建元组。小括号可以省略。**  

```
 a = (10,20,30) `或者` a = 10,20,30 
```

**如果元组只有一个元素，则必须后面加逗号。**这是因为解释器会把(1)解释为整数 1，(1,) 解释为元组。

```python
>>> a = (1)
>>> type(a)
<class 'int'>
>>> a = (1,) # 或者 a = 1,
>>> type(a)
<class 'tuple'>
```

- **通过 tuple()创建元组**  

```python
tuple(可迭代的对象)
例如：
b = tuple() # 创建一个空元组对象
b = tuple("abc")  # （'a','b','c'）
b = tuple(range(3)) # (1,2,3)
b = tuple([2,3,4])
```

- **生成器推导式创建元组**  

从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。

我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的`__next__()` 方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象。   

**生成器的使用测试**

```python
>>> s = (x*2 for x in range(5))
>>> s
<generator object <genexpr> at 0x0000000002BDEB48>
>>> tuple(s)
(0, 2, 4, 6, 8)
>>> list(s) #只能访问一次元素。第二次就为空了。需要再生成一次
[]
>>> s
<generator object <genexpr> at 0x0000000002BDEB48>
>>> tuple(s)
()
>>> s = (x*2 for x in range(5))
>>> s.__next__()
0
>>> s.__next__()
2
>>> s.__next__()
4
```

> **总结：**  
>
> `tuple()`可以接收列表、字符串、其他序列类型、迭代器等生成元组。 
>
> `list()`可以接收元组、字符串、其他序列类型、迭代器等生成列表。
>
> - 元组的核心特点是：不可变序列。 
>
> - 元组的访问和处理速度比列表快。 
>
> - 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。  
>
> 和列表的区别：  
>
> - 元组中的数据内容不能改变，列表中的可以改变 
>
> - 元组使用（），列表使用[]    
>
>  应用：在函数的传参或者返回值中使用，保证数据不会被修改  

### 2.2  元组的元素访问和计数  

- 元组的元素不能修改  

```python
>>> a = (20,10,30,9,8)
>>> a[3]=33
Traceback (most recent call last):
File "<pyshell#313>", line 1, in <module>
a[3]=33
TypeError: 'tuple' object does not support item assignment
```

- 元组的元素访问和列表一样，通过下标访问，返回一个元组元素。

```python
>>> a = (20,10,30,9,8)
>>> a[1]
10
>>> a[1:3]
(10, 30)
>>> a[:4]
(20, 
```

- 列表关于排序的方法 list.sorted()是修改原列表对象，元组没有该方法。如果要对元组排序，只能使用内置函数 

```python
>>> a = (20,10,30,9,8)
>>> sorted(a)
[8, 9, 10, 20, 30]
```

###  2.3  zip  

- zip(列表 1，列表 2，...)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象(由这些元组组成的列表)。  

```python
>>> a = [10,20,30]
>>> b = [40,50,60]
>>> c = [70,80,90]
>>> d = zip(a,b,c)
>>> list(d)
[(10, 40, 70), (20, 50, 80), (30, 60, 90)]
```

## 3、字典  

字典是“键值对”的**无序可变序列**，字典中的每个元素都是一个“键值对”，包含：“键 对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。  

列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值 对象”。“键”是任意的不可变数据，比如：整数、浮点数、字符串、元组。但是：列表、 字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。  

“值”可以是任意的数据，并且可重复。  

一个典型的字典的定义方式：  

```python
 a = {'name':'zhangsan','age':18,'job':'programmer'}  
```

### 3.1  字典的创建  

- 我们可以通过`{}`、`dict()`来创建字典对象。

```python
>>> a = {'name':'xiaoming','age':18,'job':'programmer'}
>>> b = dict(name='xiaoming',age=18,job='programmer')
>>> a = dict([("name","xiaoming"),("age",18)])
>>> c = {} #空的字典对象
>>> d = dict() #空的字典对象
```

- 通过 zip()创建字典对象

```python

>>> k = ['name','age','job']
>>> v = ['xiaoming',18,'techer']
>>> d = dict(zip(k,v))
>>> d
{'name': 'xiaoming', 'age': 18, 'job': 'techer'}
```

- 通过 fromkeys 创建值为空的字典

```python
>>> a = dict.fromkeys(['name','age','job'])
>>> a
{'name': None, 'age': None, 'job': None}
```

### 3.2  字典元素的访问

 为了测试各种访问方法，我们这里设定一个字典对象：  

```python
 a = {'name':'xiaoming','age':18,'job':'programmer'}  
```

-  通过 `[键]` 获得“值”。若键不存在，则抛出异常。  

```python
>>> a = {'name':'xiaoming','age':18,'job':'programmer'}
>>> a['name']
'xiaoming' >>> a['age']
18
>>> a['sex']
Traceback (most recent call last):
File "<pyshell#374>", line 1, in <module>
a['sex']
KeyError: 'sex'
```

-  通过`get()`方法获得“值”。推荐使用。
  - 优点是：指定键不存在，返回 None；
  - 也可以设定指定键不存在时默认返回的对象。 

```python
>>> a.get('name')
'xiaoming' 
>>> a.get('sex')
>>> a.get('sex','一个男人')
'一个男人'
```

- 列出所有的键值对  

```python
>>> a.items()
dict_items([('name', 'gaoqi'), ('age', 18), ('job', 'programmer')])
```

- 列出所有的键，列出所有的值  

```python
>>> a.keys()
dict_keys(['name', 'age', 'job'])
>>> a.values()
dict_values(['gaoqi', 18, 'programmer'])
```

- `len()` 键值对的个数 

```python
>>> len(a)
3
```

- 检测一个“键”是否在字典中  

```python
>>> a = {"name":"gaoqi","age":18}
>>> "name" in a
True
```

### 3.3  字典元素添加、修改、删除  

- 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在， 则新增“键值对”。  

```python
>>>a = {'name':'deli','age':18,'job':'programmer'}
>>> a['address']='西三旗 1 号院' 
>>> a['age']=16
>>> a
{'name': 'deli', 'age': 16, 'job': 'programmer', 'address': '西三旗 1 号院'}
```

- 使用`update()`将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直接覆盖。  

```python
>>> a = {'name':'deli','age':18,'job':'programmer'}
>>> b = {'name':'xixi','money':1000,'sex':'男的'}
>>> a.update(b)
>>> a
{'name': 'xixi', 'age': 18, 'job': 'programmer', 'money': 1000, 'sex': '男的'}
```

- 字典中元素的删除，可以使用 `del()`方法；或者 `clear()`删除所有键值对；`pop()`删除指定键值对，并返回对应的“值对象”；  

```python
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> del(a['name'])
>>> a
{'age': 18, 'job': 'programmer'}
>>> b = a.pop('age')
>>> b
18
```

- ` popitem() `：随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元 素、最后一个元素的概念；`popitem` 弹出随机的项，因为字典并没有"最后的元素"或者其 他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先 获取键的列表）。  

```python
>>> a = {'name':'deli','age':18,'job':'programmer'}
>>> a.popitem()
('job', 'programmer')
>>> a
{'name': 'deli', 'age': 18}
>>> a.popitem()
('age', 18)
>>> a
{'name': 'deli'}
```

### 3.3  序列解包  

序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。  

```python
>>> x,y,z=(20,30,10)
>>> x
20
>>> y
30
>>> z
10
>>> (a,b,c)=(9,8,10)
>>> a
9
>>> [a,b,c]=[10,20,30]
>>> a
10
>>> b
20
```

- 序列解包用于字典时，默认是对“键”进行操作； 如果需要对键值对操作，则需要使用 `items()；`如果需要对“值”进行操作，则需要使用 `values()`；  

```python
>>> s = {'name':'deli','age':18,'job':'teacher'}
>>> name,age,job=s #默认对键进行操作
>>> name
'name' 
>>> name,age,job=s.items() #对键值对进行操作
>>> name
('name', 'deli')
>>> name,age,job=s.values() #对值进行操作
>>> name
'gaoqi'
```

 **表格数据使用字典和列表存储，并实现访问**  

| 姓名   | 年龄 | 薪资  | 城市 |
| ------ | ---- | ----- | ---- |
| 高小一 | 18   | 30000 | 北京 |
| 高小二 | 19   | 20000 | 上海 |
| 高小五 | 20   | 10000 | 深圳 |

```python
r1 = {"name":"高小一", "age":18, "salary":30000, "city":"北京"}
r2 = {"name":"高小二", "age":19, "salary":20000, "city":"上海"}
r3 = {"name":"高小五", "age":20, "salary":10000, "city":"深圳"}
tb = [r1,r2,r3]
# 获得第二行的人的薪资
print(tb[1].get("salary"))
# 打印表中所有的的薪资
for i in range(len(tb)): 	# i -->0,1,2
	print(tb[i].get("salary"))
# 打印表的所有数据
for i in range(len(tb)):
	print(tb[i].get("name"), tb[i].get("age"), tb[i].get("salary"), tb[i].get("city"))
```

### 3.5  字典核心底层原理(重要)  

字典对象的核心是散列表。散列表是一个稀疏数组（总是有空白元素的数组），数组的 每个单元叫做 `bucket`。每个 `bucket` 有两部分：一个是键对象的引用，一个是值对象的引用。  

 由于，所有 `bucket` 结构和大小一致，我们可以通过偏移量来读取指定 `bucket`。  

![image.png](https://gitee.com/iscn/md_images/raw/master/python/bucket.png)

- **将一个键值对放进字典的底层过程**  

```python
>>> a = {} 
>>> a["name"]="deli" 
```

假设字典 a 对象创建完后，数组长度为8  

![image.png](https://gitee.com/iscn/md_images/raw/master/python/1652770134955-133e3425-afd0-4856-86aa-5f99ee27a856.png)

我们要把`”name”=”deli”`这个键值对放到字典对象 a 中，首先第一步需要计算键”name”的散列值。Python 中可以通过 `hash()`来计算。

```python
>>> bin(hash("name"))
'0b1000101001001101011010100011010100001000010110111000100011111'
```

由于数组长度为 8，我们可以拿计算出的散列值的最右边 3 位数字作为偏移量，即 “101”，十进制是数字 5。我们查看偏移量 5，对应的 `bucket` 是否为空。如果为空，则 将键值对放进去。如果不为空，则依次取右边 3 位作为偏移量，即“100”，十进制是数字3。再查看偏移量为 3 的 `bucket` 是否为空。直到找到为空的 `bucket` 将键值对放进去。流程图如下：

![image.png](https://gitee.com/iscn/md_images/raw/master/python/1652770185998-90683f83-61a4-4574-bbef-6b911a77cbfb.png)

**扩容**:python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容拷贝到新数组中。接近 2/3 时，数组就会扩容  

- **根据键查找“键值对”的底层过程**

我们明白了，一个键值对是如何存储到数组中的，根据键对象取到值对象，理解起来就简单了。  

```python
>>> a.get("name") 
'deli' 
```

当我们调用`a.get(“name”)`，就是根据键`"name"`查找到“键值对”，从而找到值对象“deli”。  

**第一步，**我们仍然要计算`“name”`对象的散列值：  

```python
>>> bin(hash("name"))
'-0b1010111101001110110101100100101'
```

和存储的底层流程算法一致，也是依次取散列值的不同位置的数字。 假设数组长度为 8，我们可以拿计算出的散列值的最右边 3 位数字作为偏移量，即“101”，十进制是数字5。我们查看偏移量 5，对应的 bucket 是否为空。如果为空，则返回 None。如果不为空， 则将这个 bucket 的键对象计算对应散列值，和我们的散列值进行比较，如果相等。则将对 应“值对象”返回。如果不相等，则再依次取其他几位数字，重新计算偏移量。依次取完后， 仍然没有找到。则返回 None。流程图如下：  

![img](https://gitee.com/iscn/md_images/raw/master/python/1652770323418-800ac8d6-dff0-497b-8515-8651effe67cc.png)

> 用法总结：  
>
> - 键必须可散列 
>   - 数字、字符串、元组，都是可散列的。
>
>   - 自定义对象需要支持下面三点：  
>
>     - 支持 hash()函数 
>
>     - 支持通过__eq__()方法检测相等性。 
>
>   - 若 `a==b` 为真，则 `hash(a)==hash(b)`也为真。
>
> - 字典在内存中开销巨大，典型的空间换时间。 
>
> - 键查询速度很快 
>
> - 往字典里面添加新建可能导致扩容，导致散列表中键的次序变化。因此，不要在遍历字典的同时进行字典的修改。    

## 4、集合

集合是无序可变，元素不能重复。实际上，集合底层是字典实现，集合的所有元素都是字典中的“键对象”，因此是不能重复的且唯一的。

### 4.1 集合创建和删除

- 使用{}创建集合对象，并使用 `add()`方法添加元素  

```python
>>> a = {3,5,7}
>>> a
{3, 5, 7}
>>> a.add(9)
>>> a
{9, 3, 5, 7}
```

- 使用`set()`，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保留一个。  

```python
>>> a = ['a','b','c','b']
>>> b = set(a)
>>> b
{'b', 'a', 'c'}
```

- `remove()`删除指定元素；`clear()`清空整个集合  

```python
>>> a = {10,20,30,40,50}
>>> a.remove(20)
>>> a
{10, 50, 30}
```

### 4.2 集合相关操作

像数学中概念一样，Python 对集合也提供了并集、交集、差集等运算。我们给出示例：  

```python
>>> a = {1,3,''}
>>> b = {'he','it','sxt'}
>>> a|b #并集
{1, 3, 'sxt', 'he', 'it'}
>>> a&b #交集
{'sxt'}
>>> a-b #差集
{1, 3}
>>> a.union(b) #并集
{1, 3, 'sxt', 'he', 'it'}
>>> a.intersection(b) #交集
{'sxt'}
>>> a.difference(b) #差集
{1, 3}
```

## 问一问：

> 1、集合和字典有什么关系？
> 2、元组和列表有哪些共同点，哪些不同点？
> 3、使用二维列表存储表格信息，并画出简单的内存存储图
> 4、推导式生成列表：a = [x*2 for x in range(100) if x%9==0],手写出结果