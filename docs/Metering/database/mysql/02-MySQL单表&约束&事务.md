# 02-MySQL单表&约束&事务

### 1. DQL操作单表

#### 1.1 排序

- **通过ORDER BY 子句，可以将查询除的结果进行排序(排序只是显示效果，不会影响真实数据)**
- 语法结构

```mysql
SELECT 字段名 FROM 表名 [WHERE 字段 = 值] ORDER BY [ASC/DESC]
```

| ASC表示升序排序（默认） |
| ----------------------- |
| DESC表示降序排序        |

##### 1.1.1 排序方式

1）单列排序

- **只按照某一个字段进行排序，就是单列排序**

需求1：

使用salary字段，对emp表进行排序（升序/降序）

```mysql
-- 默认升序排序 ASC
SELECT * FROM emp ORDER BY salary;
-- 降序排序
SELECT * FROM emp ORDER BY salary DESC;
```

2）组合排序

- 同时对多个字段进行排序，如果第一个字段相同，就按照第二个字段进行排序，以此类推

需求2：

在薪水排序的基础上，在使用id进行排序，如果薪水相同就id做降序排序

```mysql
--组合排序
SELECT * FROM emp ORDER BY salary DESC, eid DESC;
```

#### 1.2 聚合函数

​	之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵 向查询，它是对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空值。)；

- 语法结构

```mysql
SELECT 聚合函数（字段名） FROM 表名;
```

- 5个聚合函数

| 聚合函数      | 作用                           |
| ------------- | ------------------------------ |
| count（字段） | 统计指定列为不为NULL的记录行数 |
| sum（字段）   | 计算指定列的数值和             |
| max（字段）   | 计算指定列的最大值             |
| min（字段）   | 计算指定列的最小值             |
| avg（字段）   | 计算指定列的平均值             |

需求1：

```mysql
#1 查询员工的总数
#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值
#3 查询薪水大于4000员工的个数
#4 查询部门为'教学部'的所有员工的个数
#5 查询部门为'市场部'所有员工的平均薪水
```

SQL实现

```mysql
#1 查询员工的总数
-- 统计表中的记录条数 使用 count()
SELECT COUNT(eid) FROM emp; -- 使用某一个字段
SELECT COUNT(*) FROM emp; -- 使用 *
SELECT COUNT(1) FROM emp; -- 使用 1,与 * 效果一样
-- 下面这条SQL 得到的总条数不准确,因为count函数忽略了空值
-- 所以使用时注意不要使用带有null的列进行统计
SELECT COUNT(dept_name) FROM emp;
#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值
-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值
SELECT
SUM(salary) AS '总薪水',MAX(salary) AS '最高薪水',MIN(salary) AS '最低薪水',AVG(salary) AS '平均薪水' FROM emp;
#3 查询薪水大于4000员工的个数
SELECT COUNT(*) FROM emp WHERE salary > 4000;
#4 查询部门为'教学部'的所有员工的个数
SELECT COUNT(*) FROM emp WHERE dept_name = '教学部';
#5 查询部门为'市场部'所有员工的平均薪水
SELECT
AVG(salary) AS '市场部平均薪资'
FROM emp
WHERE dept_name = '市场部';
```

#### 1.3 分组

- **分组查询指的是使用 GROUP BY 语句，对查询的信息进行分组，相同数据作为一组**
- 语法格式

```mysql
SELECT 分组字段/聚合函数 FROM 表名 GROUP BY 分组字段 [HAVING 条件]
```

需求1：通过性别字段 进行分组

```mysql
-- 按照性别进行分组操作
SELECT * FROM emp GROUP BY sex; -- 注意 这样写没有意义
```

分析：GROUP BY 分组过程

![](https://gitee.com/iscn/md_images/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/QQ%E6%88%AA%E5%9B%BE20211004205111.png)

注意：

```mysql
分组时可以查询要分组的字段, 或者使用聚合函数进行统计操作.
* 查询其他字段没有意义
```

需求: 通过性别字段 进行分组,求各组的平均薪资

```mysql
SELECT sex, AVG(salary) FROM emp GROUP BY sex;
#查询每个部门的平均薪资
SELECT
dept_name AS '部门名称',
AVG(salary) AS '平均薪资'
FROM emp GROUP BY dept_name;
```

需求2：查询平均薪资大于6000的部门。

分析：

​	1）需要在分组后，对数据进行过滤，使用关键字 having

​	2）分组操作中的having子语句，是用于分组后对数据进行过滤的，作用类似于where条件。

SQL实现

```mysql
# 查询平均薪资大于6000的部门
-- 需要在分组后再次进行过滤,使用 having
SELECT
dept_name ,
AVG(salary)
FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name HAVING AVG(salary) >
6000 ;
```

- where与having的区别

| 过滤方式 | 特点                                                   |
| -------- | ------------------------------------------------------ |
| where    | where 进行分组前的过滤 <br />where 后面不能写 聚合函数 |
| having   | having 是分组后的过滤 <br />having 后面可以写 聚合函数 |

#### 1.4 limit关键字

limit关键字的作用

- limit是限制的意思，用于限制返回的查询结果的行数（可以通过limit指定查询多少行数据）
- limit语法是MySQL的方言，用来完成分页

语法结构

```mysql
SELECT 字段1，字段2... FROM 表名 LIMIT offset，length;
```

参数说明

- offset 起始行数, 从0开始记数, 如果省略 则默认为 0.
- length 返回的行数

需求1：

```mysql
# 查询emp表中的前 5条数据
# 查询emp表中 从第4条开始,查询6条
```

SQL实现

```mysql
# 查询emp表中的前 5条数据
-- 参数1 起始值,默认是0 , 参数2 要查询的条数
SELECT * FROM emp LIMIT 5;
SELECT * FROM emp LIMIT 0 , 5;
# 查询emp表中 从第4条开始,查询6条
-- 起始值默认是从0开始的.
SELECT * FROM emp LIMIT 3 , 6;
```

需求2：分页操作 每页显示3条数据

SQL实现

```mysql
-- 分页操作 每页显示3条数据
SELECT * FROM emp LIMIT 0,3; -- 第1页
SELECT * FROM emp LIMIT 3,3; -- 第2页 2-1=1 1*3=3
SELECT * FROM emp LIMIT 6,3; -- 第三页
-- 分页公式 起始索引 = (当前页 - 1) * 每页条数
```

### 2. SQL约束

1）约束的作用：

​	对表中的数据进行进一步的限制，从而保证数据的正确性、有效性、完整性

​	违反约束的不正确数据，将无法插入到表中

2）常见的约束

| 约束名 | 约束关键字  |
| ------ | ----------- |
| 主键   | primary key |
| 唯一   | unique      |
| 非空   | not null    |
| 外键   | foreign key |

#### 2.1 主键约束

| 特点 | 不可重复 唯一 非空           |
| ---- | ---------------------------- |
| 作用 | 用来表示数据库中的每一条记录 |

##### 2.1.1 添加主键约束

语法格式

```mysql
1、字段名 字段类型 primary key
2、primary key(字段名)
3、创建的时候不指定主键,然后通过 DDL语句进行设置
ALTER TABLE emp2 ADD PRIMARY KEY(eid);

```

DESC查看表结构

```mysql
-- 查看表的详细信息
DESC emp;
```

- **哪些字段可以作为主键**
  - 通常针对业务去设计主键,每张表都设计一个主键id
  - 主键是给数据库和程序使用的,跟最终的客户无关,所以主键没有意义没有关系,只要能够保证不重复 就好,比如 身份证就可以作为主键.

##### 2.1.2 删除主键约束

- 删除表中的主键约束（了解）

```mysql
-- 使用DDL语句 删除表中的主键
ALTER TABLE emp2 DROP PRIMARY KEY;
DESC emp2;
```

##### 2.1.3 主键的自增

**注: 主键如果让我们自己添加很有可能重复,我们通常希望在每次插入新记录时,数据库自动生成主键字段 的值.**

```mysql
关键字：
AUTO_INCREMENT
```

##### 2.1.4 修改主键自增的起始值

**默认地 AUTO_INCREMENT 的开始值是 1，如果希望修改起始值,请使用下面的方式**

```mysql
-- 创建主键自增的表,自定义自增其实值
CREATE TABLE emp2(
eid INT PRIMARY KEY AUTO_INCREMENT,
ename VARCHAR(20),
sex CHAR(1)
)AUTO_INCREMENT=100;
```

##### 2.1.5 DELETE和TRUNCATE对自增长的影响

- **删除表中所有数据有两种方式**

| 清空表数据的方式 | 特点                                                         |
| ---------------- | ------------------------------------------------------------ |
| DELETE           | 只是删除表中所有数据，对自增没有影响                         |
| TRUNCATE         | truncate 是将整个表删除掉,然后创建一个新的表<br /> 自增的主键,重新从 1开始 |

#### 2.2 非空约束

**非空约束的特点：某一列不允许为空**

语法格式

```mysql
字段名 字段类型 not null
```

#### 2.3 唯一约束

**唯一约束的特点: 表中的某一列的值不能重复( 对null不做唯一的判断 )**

语法格式

```mysql
字段名 字段值 unique
```

- **主键约束与唯一约束的区别**
  - 主键约束唯一且不能为空
  - 唯一约束，唯一可以为空
  - 一个表中只能有一个主键，但是可以有多个唯一约束

#### 2.4外键约束

- **FOREIGN KEY 表示外键约束，将在多表中学习。**

#### 2.5 默认值

**默认值约束 用来指定某列的默认值**

语法格式

```mysql
字段名 字段类型 DEFAULT 默认值
```

需求：创建emp1表，eid 主键自增约束，ename 非空约束，sex字段默认女

```mysql
-- 创建带有默认值的表
CREATE TABLE emp4(
eid INT PRIMARY KEY AUTO_INCREMENT,
ename VARCHAR(20) NOT NULL,
sex CHAR(1) DEFAULT '女'
);
```

### 3数据库事务

#### 3.1 什么是事务

​	事务是一个整体,由一条或者多条SQL 语句组成,这些SQL语句要么都执行成功,要么都执行失败, 只要有 一条SQL出现异常,整个操作就会回滚,整个业务执行失败

```mysql
比如: 银行的转账业务,张三给李四转账500元 , 至少要操作两次数据库, 张三 -500, 李四 + 500,这中
间任何一步出现问题,整个操作就必须全部回滚, 这样才能保证用户和银行都没有损失.
```

- 回滚

  ​	即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成 的操作全部撤销，滚回到事务开始时的状态。（在提交之前执行）

#### 3.2 MySQL事务操作

- MySQL中可以有两种方式进行事务的操作
  - 手动提交事务
  - 自动提交事务

##### 3.2.1 手动提交事务

- 语法格式

| 功能     | 语句                           |
| -------- | ------------------------------ |
| 开启事务 | start transaction; 或者 BEGIN; |
| 提交事务 | commit;                        |
| 回滚事务 | rollback;                      |

- START TRANSACTION  
  - 这个语句显式地标记一个事务的起始点。
- COMMIT 
  - 表示提交事务，即提交事务的所有操作，具体地说，就是将事务中所有对数据库的更新都写 到磁盘上的物理数据库中，事务正常结束。 
- ROLLBACK 
  - 表示撤销事务，即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中 对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态

**手动提交事务流程**

- 执行成功的情况： 开启事务 -> 执行多条 SQL 语句 -> 成功提交事务
- 执行失败的情况： 开启事务 -> 执行多条 SQL 语句 -> 事务的回滚

##### 3.2.2 自动提交事务

​	MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句 执行完毕 自动提交事务，MySQL 默认开始自动提交事务

- 取消自动提交
  - MySQL默认是自动提交事务，设置为手动提交

1）登录MySQL，查看autocommit 状态

```mysql
SHOW VARIABLES LIKE 'autocommit';--ON：自动提交；OFF：手动提交
```

2）把autocommit 改成 off;

```mysql
SET @@autocommit=off;
```

#### 3.3 事务的四大特性

| 特性   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 原子性 | 每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都 失败。 |
| 一致性 | 事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前2个人的 总金额 是 2000，转账后 2 个人总金额也是 2000. |
| 隔离性 | 事务与事务之间不应该相互影响，执行时保持隔离的状态.          |
| 持久性 | 一旦事务执行成功，对数据库的修改是持久的。就算关机，数据也是要保存下来的. |

#### 3.4 MySQL事务隔离级别（了解）

##### 3.4.1 数据并发访问

​	一个数据库可能拥有多个访问客户端,这些客户端都可以并发方式访问数据库. 数据库的相同数据可能 被多个事务同时访问,如果不采取隔离措施,就会导致各种问题, 破坏数据的完整性

##### 3.4.2 并发访问会产生的问题

​	事务在操作时的理想状态： 所有的事务之间保持隔离，互不影响。因为并发操作，多个用户同时访问同一个数据。可能引发并发访问的问题

| 并发访问的问题 | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 脏读           | 一个事务读取到了另一个事务中尚未提交的数据                   |
| 不可重复读     | 一个事务中两次读取的数据内容不一致, 要求的是在一个事务中多次读取时数据是一 致的. 这是进行 update 操作时引发的问题 |
| 幻读           | 一个事务中,某一次的 select 操作得到的结果所表征的数据状态, 无法支撑后续的业务 操作. 查询得到的数据状态不准确,导致幻读. |

##### 3.4.3 四种隔离级别

通过设置隔离级别，可以防止上面三种并发问题。

MySQL数据库有四种隔离级别，上面的级别最低，下面的级别最高。

- ✔ 会出现问题
- ✘ 不会出现问题

| 级别 | 名字     | 隔离级别         | 脏读 | 不可重复读 | 幻读 | 数据库的默认隔离级别 |
| ---- | -------- | ---------------- | ---- | ---------- | ---- | -------------------- |
| 1    | 读未提交 | read uncommitted | ✔    | ✔          | ✔    |                      |
| 2    | 读已提交 | read committed   | ✘    | ✔          | ✔    | Oracle和SQLServer    |
| 3    | 可重复读 | repeatable read  | ✘    | ✘          | ✔    | MySql                |
| 4    | 串行化   | serializable     | ✘    | ✘          | ✘    |                      |

##### 3.4.4 隔离级别的相关命令

1）查看隔离级别

```mysql
select @@tx_isolation;
```

2）设置事务隔离级别，需要退出MySQL再重新登录才能看到隔离级别的变化

```mysql
set global transaction isolation level 级别名称;
read uncommitted 读未提交
read committed 读已提交
repeatable read 可重复读
serializable 串行化
```

例如：修改隔离级别为 读未提交

```mysql
set global transaction isolation level read uncommitted;
```

## 