# 06-存储结构与管理硬盘

## 1、一切从“/”开始

在`Linux`系统中，目录、字符设备、套接字、硬盘、光驱、打印机等都被抽象成文件形式，即刘遄老师一直强调的“Linux系统中一切都是文件”。既然平时我们打交道的都是文件，那么又应该如何找到它们呢？在Windows操作系统中，想要找到一个文件，要依次进入该文件所在的磁盘分区（也叫盘符），然后再进入该分区下的具体目录，最终找到这个文件。但是在Linux系统中并不存在C、D、E、F等盘符，Linux系统中的一切文件都是从“`根`”目录（`/`）开始的，并按照文件系统层次标准（`FHS`）采用倒树状结构来存放文件，以及定义了常见目录的用途。

另外，`Linux`系统中的文件和目录名称是严格区分大小写的。例如，`root`、`rOOt`、`Root`、`rooT`均代表不同的目录，并且文件名称中不得包含斜杠（`/`）。Linux系统中的文件存储结构如下图所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/Linux%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png)

前文提到的`FHS`是根据以往无数Linux系统用户和开发者的经验而总结出来的，是用户在Linux系统中存储文件时需要遵守的规则，用于指导用户应该把文件保存到什么位置，以及告诉用户应该在何处找到所需的文件。但是，FHS对于用户来讲只能算是一种道德上的约束，有些用户就是懒得遵守，依然会把文件到处乱放，有些甚至从来没有听说过它。这里并不是号召各位读者去谴责他们，而是建议大家要灵活运用所学的知识，千万不要认准这个`FHS`协定只讲死道理，不然吃亏的可就是自己了。在Linux系统中，最常见的目录以及所对应的存放内容如下表所示。

| 目录名称    | 应放置文件的内容                                             |
| ----------- | ------------------------------------------------------------ |
| /boot       | 系统启动文件，如内核和启动菜单                               |
| /dev        | 设备文件，代表系统中的硬件设备                               |
| /etc        | 系统配置文件和启动[脚本](https://www.linuxcool.com/)         |
| /root       | 管理员的个人主目录                                           |
| /home       | 用户的个人主目录                                             |
| /bin        | 基本用户[命令](https://www.linuxcool.com/)，可在单用户模式下使用 |
| /lib        | 系统共享库，供/bin和/sbin命令使用                            |
| /sbin       | 系统管理命令，供管理员使用                                   |
| /media      | 挂载点目录，用于可移动设备                                   |
| /opt        | 第三方应用软件包                                             |
| /srv        | 服务数据目录，存放网络服务数据                               |
| /tmp        | 临时文件目录，所有用户均可访问                               |
| /proc       | 虚拟文件系统，提供进程和内核信息                             |
| /usr/local  | 本地安装的软件和应用程序                                     |
| /usr/sbin   | 系统管理员使用的非基本管理命令                               |
| /usr/share  | 共享数据，如文档和帮助文件                                   |
| /var        | 动态数据，如日志文件和临时文件                               |
| /lost+found | 文件系统恢复区，存放丢失的文件碎片                           |



在Linux系统中另外还有一个重要的概念—路径。路径指的是如何定位到某个文件，分为绝对路径与相对路径。绝对路径指的是从根目录（`/`）开始写起的文件或目录名称，而相对路径则指的是相对于当前路径的写法。我们来看下面这个例子，以帮助大家理解。假如有位外国游客来到北京潘家园旅游，当前内急但是找不到洗手间，特意向您问路，那么咱们有两种正确的指路方法。

> **绝对路径（absolute path）**：首先坐飞机来到中国，到了北京后出首都机场，坐机场快轨到三元桥，然后换乘10号线到潘家园站，出站后坐34路公交车到农光里，下车后路口左转。
>
> **相对路径（relative path）**：前面路口左转。

这两种方法都正确。如果您说的是绝对路径，那么任何一位外国游客都可以按照这个提示找到潘家园的洗手间，但是太繁琐了。如果说的是相对路径，虽然表达很简练，但是这位外国游客只能从当前位置（不见得是潘家园）出发找到洗手间，因此并不能保证在前面的路口左转后可以找到洗手间。由此可见，相对路径不具备普适性。

如果各位读者现在还是不能理解相对路径和绝对路径的区别，也不要着急，以后通过实践练习肯定可以彻底搞明白。当前建议大家先记住`FHS`中规定的目录作用，这将在以后派上用场。

## 2、物理设备的命名规则

在Linux系统中一切都是文件，硬件设备也不例外。既然是文件，就必须有文件名称。系统内核中的`udev`设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等；这对于陌生的设备来说特别方便。另外，`udev`设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理`/dev`目录下的设备文件。Linux系统中常见的硬件设备及其文件名称如下表所示。

| 硬件设备      | 文件名称           |
| ------------- | ------------------ |
| IDE设备       | /dev/hd[a-d]       |
| NVMe设备      | /dev/nvme[0-23]    |
| SCSI/SATA/U盘 | /dev/sd[a-z]       |
| virtio设备    | /dev/vd[a-z]       |
| 软驱          | /dev/fd[0-1]       |
| 打印机        | /dev/lp[0-15]      |
| 光驱          | /dev/cdrom         |
| 鼠标          | /dev/mouse         |
| 磁带机        | /dev/st0或/dev/ht0 |

由于现在的`IDE`设备已经很少见了，所以一般的硬盘设备都是以“`/dev/sd`”开头。而一台主机上可以有多块硬盘，因此系统采用`a～z`来代表26块不同的硬盘（默认从`a`开始分配），而且硬盘的分区编号也很有讲究：

> 主分区或扩展分区的编号从1开始，到4结束；
>
> 逻辑分区从编号5开始。

`/dev`目录中`sda`设备之所以是`a`，并不是由插槽决定的，而是由系统内核的识别顺序来决定的，而恰巧很多主板的插槽顺序就是系统内核的识别顺序，因此才会被命名为`/dev/sda`。大家以后在使用`iSCSI`网络存储设备时就会发现，明明主板上第二个插槽是空着的，但系统却能识别到`/dev/sdb`这个设备—就是这个道理。

很多Linux培训讲师会告诉学员，分区的编号代表分区的个数。比如`sda3`表示这是设备上的第3个分区，而学员在做实验的时候确实也会得出这样的结果。但是这个理论知识是错误的，因为分区的数字编码不一定是强制顺延下来的，也有可能是手工指定的。因此`sda3`只能表示是编号为3的分区，而不能判断`sda`设备上已经存在了3个分区。

在填了这两个“坑”之后，再来分析一下`/dev/sda5`这个设备文件名称包含哪些信息，如图6-2所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/%E7%A1%AC%E7%9B%98%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99.png)

首先，`/dev/`目录中保存的应当是硬件设备文件；其次，`sd`表示的是存储设备；然后，`a`表示系统中同类接口中第一个被识别到的设备；最后，`5`表示这个设备是一个逻辑分区。一言以蔽之，“`/dev/sda5`”表示的就是“这是系统中第一块被识别到的硬件设备中分区编号为`5`的逻辑分区的设备文件”。考虑到很多读者完全没有Linux基础，不太容易理解前面所说的主分区、扩展分区和逻辑分区的概念，因此接下来简单科普一下硬盘相关的知识。

正是因为计算机有了硬盘设备，我们才能够在玩游戏的过程中或游戏通关之后随时存档，而不用每次重头开始。硬盘设备是由大量的扇区组成的，每个扇区的容量为512字节。其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。就第一个扇区来讲，主引导记录需要占用446字节，分区表占用64字节，结束符占用2字节；其中分区表中每记录一个分区信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。第一个扇区中的数据信息如下图所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%89%87%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF-1.jpg)

现在，问题来了—每块硬盘最多只能创建出4个分区？这明显不合情理也不够用。

于是为了解决分区个数不够的问题，可以将第一个扇区的分区表中16字节（原本要写入主分区信息）的空间（称之为扩展分区）拿出来指向另外一个分区。也就是说，扩展分区其实并不是一个真正的分区，而更像是一个占用16字节分区表空间的指针—一个指向另外一个分区的指针。这样一来，用户一般会选择使用3个主分区加1个扩展分区的方法，然后在扩展分区中创建出数个逻辑分区，从而来满足多分区（大于4个）的需求。当然，就目前来讲大家只要明白为什么主分区不能超过4个就足够了。主分区、扩展分区、逻辑分区可以像图6-4那样来规划。

> 所谓扩展分区，严格地讲它不是一个实际意义的分区，而仅仅是一个指向其他分区的指针，这种指针结构将形成一个单向链表。因此扩展分区自身不能存储数据，用户需要在其指向的对应分区（称之为逻辑分区）上进行操作。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA.png)

**大家可以试着解读一下/dev/hdc8代表着什么？** （**答案模式**）

**答案：**这是第3块IDE设备（现在比较少见）中编号为8的逻辑分区。

对了！如果大家参加红帽考试或者购买了一台云主机，还会看到类似于`/dev/vda`、/dev/vdb这样的设备。这种以`vd`开头的设备叫作`Virtio`设备，简单来说就是一种虚拟化设备。像`KVM`、`Xen`这种虚拟机监控器（Hypervisor）默认就都是这种设备，等大家步入工作岗位后可能会见到更多。

## 3、文件系统与数据资料

离开了格式约束之后的内容，完全不受我们的主观控制。而用户在硬件存储设备中执行的文件建立、写入、读取、修改、转存与控制等操作都是依靠文件系统来完成的。文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。

Linux系统支持数十种文件系统，而最常见的文件系统如下所示。

- **Ext2**：最早可追溯到1993年，是Linux系统的第一个商业级文件系统，它基本沿袭了UNIX文件系统的设计标准。但由于不包含日志读写功能，数据丢失的可能性很大，因此大家能不用就不用，或者顶多建议用于SD存储卡或U盘。

- **Ext3**：是一款日志文件系统，它会把整个硬盘的每个写入动作的细节都预先记录下来，然后再进行实际操作，以便在发生异常宕机后能回溯追踪到被中断的部分。`Ext3`能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能100%地保证资料不会丢失。

- **Ext4**：`Ext3`的改进版本，作为RHEL 6系统中默认的文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block（块），从而极大地提高了读写效率。现在很多主流服务器也会使用`Ext4`文件系统。

- **XFS**：是一种高性能的日志文件系统，而且是RHEL 7/8中默认的文件管理系统。它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只需花费极低的计算和存储性能。它支持的最大存储容量为18EB，这几乎满足了所有需求。

RHEL 7/8系统中一个比较大的变化就是使用了XFS作为文件系统，这不同于RHEL 6使用的Ext4。从红帽公司官方发布的说明来看，这确实是一个不小的进步，但是刘遄老师在实测中发现并不完全属实。因为单纯就测试一款文件系统的“读取”性能来说，到底要读取多少个文件，每个文件的大小是多少，读取文件时的CPU、内存等系统资源的占用率如何，以及不同的硬件配置是否会有不同的影响，这些因素都是不确定的，因此实在不敢直接照抄红帽官方的介绍。我个人认为XFS虽然在性能方面比Ext4有所提升，但绝不是压倒性的，因此XFS文件系统最卓越的亮点应该当属可支持高达18EB的存储容量吧。

18EB等于18,874,368TB。假设每块硬盘的容量是100TB，那么大概需要19万块硬盘才能把18EB的数据都装下。总之，当用了`XFS`之后，文件的存储上限就不再取决于技术层面，而是钱包了。过去常常跟同学们开玩笑，“如果有18EB的数据在上海机房，想以最快的方式传送到北京，我们有什么好办法呢？”答案是“乘坐京沪高铁”。

在拿到一块新的硬盘存储设备后，先需要分区，然后再格式化文件系统，最后才能挂载并正常使用。硬盘的分区操作取决于您的需求和硬盘大小；也可以选择不进行分区，但是必须对硬盘进行格式化处理。

> 就像拿到了一张未裁切的完整纸张那样，首先要进行裁切以方便使用（**分区**），接下来在裁切后的纸张上画格以便能书写工整（格式化），最后是正式的使用（**挂载**）。

接下来向大家简单地科普一下硬盘在格式化后发生的事情。再次强调，大家不用刻意去记住，只要能看懂就行了。

日常需要保存在硬盘中的数据实在太多了，因此Linux系统中有一个名为super block的“硬盘地图”。Linux并不是把文件内容直接写入到这个“硬盘地图”里面，而是在里面记录着整个文件系统的信息。因为如果把所有的文件内容都写入到这里面，它的体积将变得非常大，而且文件内容的查询与写入速度也会变得很慢。Linux只是把每个文件的权限与属性记录在`inode`中，而且每个文件占用一个独立的`inode`表格，该表格的大小默认为128字节，里面记录着如下信息：

> 该文件的访问权限（read、write、execute）；
>
> 该文件的所有者与所属组（owner、group）；
>
> 该文件的大小（size）；
>
> 该文件的创建或内容修改时间（Ctime）；
>
> 该文件的最后一次访问时间（Atime）；
>
> 该文件的修改时间（Mtime）；
>
> 文件的特殊权限（SUID、SGID、SBIT）；
>
> 该文件的真实数据地址（point）。

而文件的实际内容则保存在`block`块中（大小一般是1KB、2KB或4KB），一个inode的默认大小仅为128字节，记录一个`block`则消耗4字节。当文件的`inode`被写满后，Linux系统会自动分配出一个block，专门用于像`inode`那样记录其他`block`块的信息，这样把各个`block`块的内容串到一起，就能够让用户读到完整的文件内容了。对于存储文件内容的block块，有下面两种常见的情况（以4KB大小的block为例进行说明）。

> 情况1：文件很小（1KB），但依然会占用一个block，因此会潜在地浪费3KB。
>
> 情况2：文件很大（5KB），那么会占用两个block（5KB−4KB后剩下的1KB也要占用一个block）。

大家看到这里，是不是觉得Linux系统好浪费啊？为什么最后一个`block`块容量总不能被完全使用呢？其实每个系统都是一样的，只不过大家此前没有留意过罢了。同学们可以随手查看一个电脑中已有的文件，看看文件的实际大小与占用空间是否一致，如图6-5所示。

计算机系统在发展过程中产生了众多的文件系统，为了使用户在读取或写入文件时不用关心底层的硬盘结构，Linux内核中的软件层为用户程序提供了一个虚拟文件系统（Virtual File System，VFS）接口，这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作了。下图所示为VFS的架构示意图。从中可见，实际文件系统在`VFS`下隐藏了自己的特性和细节，这样用户在日常使用时会觉得“文件系统都是一样的”，也就可以随意使用各种命令在任何文件系统中进行各种操作了（比如使用`cp`命令来复制文件）。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E6%96%87%E4%BB%B6%E7%9A%84%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F.png)

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/VFS%E7%9A%84%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE-1.jpg)

`VFS`也有点像一个翻译官。我们不需要知道对方的情况，只要告诉`VFS`想进行的操作是什么，它就会自动判断对方能够听得懂什么指令，然后翻译并交代下去。这可以让用户不用操心这些“小事情”，专注于自己的操作。

> 在医学圈里有句这样一句话，“当您开始关注身体某个器官的时候，大概率是它最近不舒服了”。由于VFS真的太好用了，而且几乎不会出现任何问题，所以如果不在这里讲一下它的理论，相信很多同学很可能在多年后都不知道自己用过它。

## 4、挂载硬件设备

我们在用惯了Windows系统后总觉得一切都是理所当然的，平时把U盘插入到电脑后也从来没有考虑过Windows系统做了哪些事情，才使得我们可以访问这个U盘的。接下来我们会逐一学习在Linux系统中挂载和卸载存储设备的方法，以便大家更好地了解Linux系统添加硬件设备的工作原理和流程。前面讲到，在拿到一块全新的硬盘存储设备后要先分区，然后格式化，最后才能挂载并正常使用。“分区”和“格式化”大家以前经常听到，但“挂载”又是什么呢？

刘遄老师在这里给您一个最简单、最贴切的解释—当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”。下文将向读者逐步讲解如何使用硬盘设备，但是鉴于与挂载相关的理论知识比较复杂，而且很重要，因此决定再拿出一个小节单独讲解，这次希望大家不仅要看懂，而且还要记住。

`mount`命令用于挂载文件系统，格式为“`mount 文件系统 挂载目录`”。`mount`命令中可用的参数及作用如下表所示。挂载是在使用硬件设备前所执行的最后一步操作。只需使用`mount`命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设备中的数据了。对于比较新的Linux系统来讲，一般不需要使用-t参数来指定文件系统的类型，Linux系统会自动进行判断。而`mount`中的-a参数则厉害了，它会在执行后自动检查`/etc/fstab`文件中有无被疏漏挂载的设备文件，如果有，则进行自动挂载操作。

`mount`命令中的参数以及作用

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -a   | 挂载所有在/etc/fstab中定义的文件系统 |
| -t   | 指定文件系统的类型                   |

例如，要把设备`/dev/sdb2`挂载到`/backup`目录，只需要在`mount`命令中填写设备与挂载目录参数就行，系统会自动判断要挂载文件的类型，命令如下：

```bash
[root@linuxprobe ~]# mount /dev/sdb2 /backup
```

如果在工作中要挂载一块网络存储设备，该设备的名字可能会变来变去，这样再写为`sdb`就不太合适了。这时推荐用`UUID`（Universally Unique Identifier，通用唯一识别码）进行挂载操作。`UUID`是一串用于标识每块独立硬盘的字符串，具有唯一性及稳定性，特别适合用来挂载网络设备。那么，怎么才能得知独立硬盘的`UUID`呢？答案是使用`blkid`命令。

`blkid`命令用于显示设备的属性信息，英文全称为“block id”，语法格式为“`blkid [设备名]`”。使用`blkid`命令来查询设备`UUID`的示例如下：

```bash
[root@linuxprobe ~]# blkid
/dev/sdb1: UUID="2db66eb4-d9c1-4522-8fab-ac074cd3ea0b" TYPE="xfs" PARTUUID="eb23857a-01"
/dev/sdb2: UUID="478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG" TYPE="ext4" PARTUUID="eb23857a-02"
```

有了设备的`UUID`值之后，就可以用它挂载网络设备了：

```bash
[root@linuxprobe ~]# mount UUID=478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG /backup
```

虽然按照上面的方法执行`mount`命令后就能立即使用文件系统了，但系统在重启后挂载就会失效，也就是说需要每次开机后都手动挂载一下。这肯定不是我们想要的效果，如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”（各字段的意义见下表）写入到`/etc/fstab`文件中。这个文件中包含着挂载所需的诸多信息项目，一旦配置好之后就能一劳永逸了。

用于挂载信息的指定填写格式中，各字段所表示的意义

| 字段     | 意义                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） |
| 挂载目录 | 指定要挂载到的目录，需在挂载前创建好                         |
| 格式类型 | 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 |
| 权限选项 | 若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async |
| 是否备份 | 若为1则开机后使用dump进行磁盘备份，为0则不备份               |
| 是否自检 | 若为1则开机后自动进行磁盘自检，为0则不自检                   |

如果想将文件系统为`Ext4`的硬件设备`/dev/sdb2`在开机后自动挂载到`/backup`目录上，并保持默认权限且无须开机自检，就需要在`/etc/fstab`文件中写入下面的信息，这样在系统重启后也会成功挂载。

```bash
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                     /        xfs     defaults    0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot    xfs     defaults    0 0
/dev/mapper/rhel-swap                     swap     swap    defaults    0 0
/dev/sdb2                                 /backup  ext4    defaults    0 0
```

由于后面需要使用系统镜像制作`Yum/DNF`软件仓库，我们提前把光盘设备挂载到`/media/cdrom`目录中。光盘设备的文件系统格式是`iso9660`：

```bash
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                     /              xfs        defaults       0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot          xfs        defaults       0 0
/dev/mapper/rhel-swap                     swap           swap       defaults       0 0
/dev/sdb2                                 /backup        ext4       defaults       0 0
/dev/cdrom                                /media/cdrom   iso9660    defaults       0 0
```

写入到`/etc/fstab`文件中的设备信息并不会立即生效，需要使用`mount -a`参数进行自动挂载：

```bash
[root@linuxprobe ~]# mount -a
```

`df`命令用于查看已挂载的磁盘空间使用情况，英文全称为“disk free”，语法格式为“`df -h`”。

如果想查看当前系统中设备的挂载情况，非常推荐大家试试`df`命令。它不仅能够列出系统中正在使用的设备有哪些，还可以用`-h`参数便捷地对存储容量进行“进位”操作。例如，在遇到10240K的时候会自动进位写成10M，非常方便我们的阅读。

```bash
[root@linuxprobe~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M   18M  966M   2% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sda1             1014M  152M  863M  15% /boot
/dev/sdb2              480M   20M  460M   4% /backup
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
```

对了！说到网络存储设备，建议您在`fstab`文件挂载信息中加上`_netdev`参数。加上后系统会等联网成功后再尝试挂载这块网络存储设备，从而避免了开机时间过长或失败的情况。

```bash
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                       /              xfs       defaults            0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b   /boot          xfs       defaults            0 0
/dev/mapper/rhel-swap                       swap           swap      defaults            0 0
/dev/sdb2                                   /backup        ext4      defaults,_netdev    0 0
/dev/cdrom                                  /media/cdrom   iso9660   defaults            0 0
```

挂载文件系统的目的是为了使用硬件资源，而卸载文件系统则意味不再使用硬件的设备资源。既然挂载操作就是把硬件设备与目录两者进行关联的动作，那么卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可，一般不需要加其他额外的参数。

`umount`命令用于卸载设备或文件系统，英文全称为“un mount”，语法格式为“`umount [设备文件/挂载目录]`”。

```bash
[root@linuxprobe ~]# umount /dev/sdb2
```

如果我们当前就处于设备所挂载的目录，系统会提示该设备繁忙，此时只需要退出到其他目录后再尝试一次就行了。轻松搞定。

```bash
[root@linuxprobe ~]# cd /media/cdrom/
[root@linuxprobe cdrom]# umount /dev/cdrom
umount: /media/cdrom: target is busy.
[root@linuxprobe  cdrom]# cd ~
[root@linuxprobe ~]# umount /dev/cdrom
[root@linuxprobe ~]#
```

> 挂载操作就像两人结为夫妻，双方需要同时到场，信息一旦被登记到民政局的系统中，再想重婚（重复挂载某设备）可就不行喽。

最后再教给同学们一个小技巧。如果系统中硬盘特别多，分区特别多，我们都不知道它们是否有被使用，又或者是做了些什么。此时，就可以用`lsblk`命令以树状图的形式列举一下了。

`lsblk`命令用于查看已挂载的磁盘的空间使用情况，英文全称为“list block id”，输入该命令后按回车键执行即可。

```bash
[root@linuxprobe ~]# lsblk 
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0   20G  0 disk 
├─sda1          8:1    0    1G  0 part /boot
└─sda2          8:2    0   19G  0 part 
  ├─rhel-root 253:0    0   17G  0 lvm  /
  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]
sr0            11:0    1  6.6G  0 rom  /media/cdrom
```

## 5 添加硬盘设备

根据前文讲解的与管理硬件设备相关的理论知识，我们先来理清一下添加硬盘设备的操作思路：首先需要在虚拟机中模拟添加入一块新的硬盘存储设备，然后再进行分区、格式化、挂载等操作，最后通过检查系统的挂载状态并真实地使用硬盘来验证硬盘设备是否成功添加。

鉴于我们不需要为了做这个实验而特意买一块真实的硬盘，而是通过虚拟机软件进行硬件模拟，因此这再次体现出了使用虚拟机软件的好处。具体的操作步骤如下。

首先把虚拟机系统关机，稍等几分钟会自动返回到虚拟机管理主界面，然后单击“编辑虚拟机设置”选项，在弹出的界面中单击“添加”按钮，新增一块硬件设备。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/1-23-1024x709.png)

选择想要添加的硬件类型为“硬盘”，然后单击“下一步”按钮就可以了，如下图所示。这确实没有什么需要进一步解释的。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/2-20.png)

选择虚拟硬盘的类型为`SATA`，并单击“下一步”按钮，如下图所示。这样虚拟机中的设备名称过一会儿后应该为`/dev/sdb`。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%A1%AC%E7%9B%98%E7%B1%BB%E5%9E%8B.png)

选中“创建新虚拟磁盘”单选按钮（而不是其他选项），再次单击“下一步”按钮，如下图所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/4-6.png)

将“最大磁盘大小”设置为默认的20GB。这个数值是限制这台虚拟机所使用的最大硬盘空间，而不是立即将其填满，因此默认20GB就很合适了。单击“下一步”按钮，如下图所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/5-5.png)

设置磁盘文件的文件名和保存位置（这里采用默认设置即可，无须修改），直接单击“完成”按钮，如下图所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%A3%81%E7%9B%98%E5%90%8D%E7%A7%B0.png)

将新硬盘添加好后就可以看到设备信息了。这里不需要做任何修改，直接单击“确定”按钮后就可以启虚拟机了，如下图所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%A1%AC%E4%BB%B6%E4%B8%80%E8%A7%88.png)

在虚拟机中模拟添加了硬盘设备后就应该能看到抽象后的硬盘设备文件了。按照前文讲解的`udev`服务命名规则，第二个被识别的`SATA`设备应该会被保存为/dev/sdb，这个就是硬盘设备文件了。但在开始使用该硬盘之前还需要进行分区操作，例如从中取出一个2GB的分区设备以供后面的操作使用。

`fdisk`命令用于新建、修改及删除磁盘的分区表信息，英文全称为“format disk”，语法格式为“`fdisk 磁盘名称`”。

在Linux系统中，管理硬盘设备最常用的方法就当属`fdisk`命令了。它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”。不过与前面讲解的直接写到命令后面的参数不同，这条命令的参数是交互式的一问一答的形式，因此在管理硬盘设备时特别方便，可以根据需求动态调整。

fdisk命令中的参数以及作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| m    | 查看全部可用的参数     |
| n    | 添加新的分区           |
| d    | 删除某个分区信息       |
| l    | 列出所有可用的分区类型 |
| t    | 改变某个分区的类型     |
| p    | 查看分区表信息         |
| w    | 保存并退出             |
| q    | 不保存直接退出         |

首先使用`fdisk`命令来尝试管理/dev/sdb硬盘设备。在看到提示信息后输入参数`p`来查看硬盘设备内已有的分区信息，其中包括了硬盘的容量大小、扇区个数等信息：

```bash
[root@linuxprobe ~]# fdisk /dev/sdb

Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x88b2c2b0.

Command (m for help): p
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0
```

输入参数`n`尝试添加新的分区。系统会要求用户是选择继续输入参数`p`来创建主分区，还是输入参数`e`来创建扩展分区。这里输入参数`p`来创建一个主分区：

```bash
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
```

在确认创建一个主分区后，系统要求用户先输入主分区的编号。在前文得知，主分区的编号范围是1～4，因此这里输入默认的1就可以了。接下来系统会提示定义起始的扇区位置，这不需要改动，敲击回车键保留默认设置即可，系统会自动计算出最靠前的空闲扇区的位置。最后，系统会要求定义分区的结束扇区位置，这其实就是要去定义整个分区的大小是多少。我们不用去计算扇区的个数，只需要输入`+2G`即可创建出一个容量为`2GB`的硬盘分区。

```bash
Partition number (1-4, default 1): 1
First sector (2048-41943039, default 2048): 此处敲击回车即可
Last sector, +sectors or +size{K,M,G,T,P} (2048-41943039, default 41943039): +2G

Created a new partition 1 of type 'Linux' and of size 2 GiB.
```

再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为`/dev/sdb1`、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时千万不要直接关闭窗口，而应该敲击参数`w`后按回车键，这样分区信息才是真正地写入成功啦。

```bash
Command (m for help): p
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0

Device     Boot Start     End Sectors Size Id Type
/dev/sdb1        2048 4196351 4194304   2G 83 Linux

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

分区信息中第6个字段的Id值是一个编码，用于标识该分区的作用，可帮助用户快速了解该分区的作用，一般没必要修改。使用l参数查看一下磁盘编码都有哪些，然后在下一小节进行`SWAP`操作时再修改吧：

```bash
Command (m for help): l  

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden or  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux extended  c7  Syrinx         
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data    
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi ea  Rufus alignment
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         eb  BeOS fs        
 f  W95 Ext'd (LBA) 54  OnTrackDM6      a6  OpenBSD         ee  GPT            
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        ef  EFI (FAT-12/16/
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f0  Linux/PA-RISC b
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f1  SpeedStor      
14  Hidden FAT16 <3 61  SpeedStor       ab  Darwin boot     f4  SpeedStor      
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      f2  DOS secondary  
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fb  VMware VMFS    
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fc  VMware VMKCORE 
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fd  Linux raid auto
1c  Hidden W95 FAT3 75  PC/IX           bc  Acronis FAT32 L fe  LANstep        
1e  Hidden W95 FAT1 80  Old Minix       be  Solaris boot    ff  BBT   
```

在上述步骤执行完毕之后，Linux系统会自动把这个硬盘主分区抽象成`/dev/sdb1`设备文件。可以使用`file`命令查看该文件的属性，但我在讲课和工作中发现，有些时候系统并没有自动把分区信息同步给Linux内核，而且这种情况似乎还比较常见（但不能算作严重的bug）。可以输入`partprobe`命令手动将分区信息同步到内核，而且一般推荐连续两次执行该命令，效果会更好。如果使用这个命令都无法解决问题，那么就重启计算机吧，这个“杀手锏”百试百灵，一定会有用的。

```bash
[root@linuxprobe ]# file /dev/sdb1
/dev/sdb1: cannot open `/dev/sdb1' (No such file or directory)
[root@linuxprobe ]# partprobe
[root@linuxprobe ]# partprobe
[root@linuxprobe ]# file /dev/sdb1
/dev/sdb1: block special
```

如果硬件存储设备没有进行格式化，则Linux系统无法得知怎么在其上写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。在Linux系统中用于格式化操作的命令是`mkfs`。这条命令很有意思，因为在Shell终端中输入`mkfs`名后再敲击两下用于补齐命令的Tab键，会有如下所示的效果：

```bash
[root@linuxprobe ~]# mkfs
mkfs         mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.vfat    
mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs     
```

对！这个`mkfs`命令很贴心地把常用的文件系统名称用后缀的方式保存成了多个命令文件，用起来也非常简单`—mkfs`.文件类型名称。例如要将分区为`XFS`的文件系统进行格式化，则命令应为`mkfs.xfs /dev/sdb1`。

```bash
[root@linuxprobe ~]# mkfs.xfs /dev/sdb1
meta-data=/dev/sdb1              isize=512    agcount=4, agsize=131072 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1
data     =                       bsize=4096   blocks=524288, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

终于完成了存储设备的分区和格式化操作，接下来就是要来挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用`mount`命令将存储设备与挂载点进行关联；最后使用`df -h`命令来查看挂载状态和硬盘使用量信息。

```bash
[root@linuxprobe ~]# mkdir /newFS
[root@linuxprobe ~]# mount /dev/sdb1 /newFS
[root@linuxprobe ~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M  9.6M  974M   1% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
/dev/sda1             1014M  152M  863M  15% /boot
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sdb1              2.0G   47M  2.0G   3% /newFS
```

`du`命令用查看分区或目录所占用的磁盘容量大小，英文全称为“disk usage”，语法格式为“`du -sh目录名称`”。

既然存储设备已经顺利挂载，接下来就可以尝试通过挂载点目录向存储设备中写入文件了。在写入文件之前，先来看一个用于查看文件数据占用量的du命令。简单来说，该命令就是用来查看一个或多个文件占用了多大的硬盘空间。

在使用Window系统时，我们总会遇到“C盘容量不足，清理垃圾后又很快被占满”的情况。在Linux系统中可以使用`du -sh /*`命令来查看在Linux系统根目录下所有一级目录分别占用的空间大小，在1s之内就能找到哪个目录占用的空间最多：

```bash
[root@linuxprobe ~]# du -sh /*
0	/bin
113M	/boot
0	/dev
29M	/etc
12K	/home
0	/lib
0	/lib64
6.7G	/media
0	/mnt
0	/newFS
0	/opt
0	/proc
8.6M	/root
9.6M	/run
0	/sbin
0	/srv
0	/sys
12K	/tmp
3.5G	/usr
155M	/var
```

先从某些目录中复制过来一批文件，然后查看这些文件总共占用了多大的容量：

```bash
[root@linuxprobe ~]# cp -rf /etc/* /newFS
[root@linuxprobe ~]# ls /newFS
adjtime                     hostname                  profile.d
aliases                     hosts                     protocols
alsa                        hosts.allow               pulse
alternatives                hosts.deny                qemu-ga
anacrontab                  hp                        qemu-kvm
asound.conf                 idmapd.conf               radvd.conf
………………省略部分输入信息………………
[root@linuxprobe ~]# du -sh /newFS
39M /newFS/
```

细心的读者一定还记得，前面在讲解mount命令时提到，使用`mount`命令挂载的设备文件会在系统下一次重启的时候失效。如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入配置文件中：

```bash
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                     /                      xfs      defaults        0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot                  xfs      defaults        0 0
/dev/mapper/rhel-swap                     swap                   swap     defaults        0 0
/dev/cdrom                                /media/cdrom           iso9660  defaults        0 0 
/dev/sdb1                                 /newFS                 xfs      defaults        0 0 
```

## 6、添加交换分区

交换（`SWAP`）分区是一种通过在硬盘中预先划分一定的空间，然后把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。通俗来讲就是让硬盘帮内存分担压力。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。

交换分区的创建过程与前文讲到的挂载并使用存储设备的过程非常相似。在对`/dev/sdb`存储设备进行分区操作前，有必要先说一下交换分区的划分建议：在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍。为了让大家更明显地感受交换分区空间的变化，这里取出一个大小为5GB的主分区作为交换分区资源：

```bash
[root@linuxprobe ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2): 敲击回车即可
First sector (4196352-41943039, default 4196352): 敲击回车即可
Last sector, +sectors or +size{K,M,G,T,P} (4196352-41943039, default 41943039): +5G

Created a new partition 2 of type 'Linux' and of size 5 GiB.
```

在上面的操作结束后，我们就得到了一个容量为5GB的新分区。然后尝试修改硬盘的标识码，这里将其改成82（Linux swap）以方便以后知道它的作用：

```bash
Command (m for help): t
Partition number (1,2, default 2): 2
Hex code (type L to list all codes): 82

Changed type of partition 'Linux' to 'Linux swap / Solaris'.

Command (m for help): p 
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0

Device     Boot   Start      End  Sectors Size Id Type
/dev/sdb1          2048  4196351  4194304   2G 83 Linux
/dev/sdb2       4196352 14682111 10485760   5G 82 Linux swap / Solaris
```

搞定！敲击`w`参数退出分区表编辑工具：

```bash
Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

下面来看一下两个与交换分区相关的简单命令。

`mkswap`命令用于对新设备进行交换分区格式化，英文全称为“make swap”，语法格式为“`mkswap 设备名称`”。

```bash
[root@linuxprobe ~]# mkswap /dev/sdb2
Setting up swapspace version 1, size = 5 GiB (5368705024 bytes)
no label, UUID=45a4047c-49bf-4c88-9b99-f6ac93908485
```

`swapon`命令用于激活新的交换分区设备，英文全称为“swap on”，语法格式为“`swapon 设备名称`”。

使用`swapon`命令把准备好的`SWAP`硬盘设备正式挂载到系统中。可以使用`free -m`命令查看交换分区的大小变化（由2047MB增加到7167MB）：

```bash
[root@linuxprobe ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1391         105          12         469         384
Swap:          2047           9        2038
[root@linuxprobe ~]# swapon /dev/sdb2
[root@linuxprobe ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1395         101          12         469         380
Swap:          7167           9        7158
```

为了能够让新的交换分区设备在重启后依然生效，需要按照下面的格式将相关信息写入配置文件中，并记得保存：

```bash
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                        /               xfs        defaults    1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b    /boot           xfs        defaults    1 2
/dev/mapper/rhel-swap                        swap            swap       defaults    0 0
/dev/cdrom                                   /media/cdrom    iso9660    defaults    0 0 
/dev/sdb1                                    /newFS          xfs        defaults    0 0 
/dev/sdb2                                    swap            swap       defaults    0 0 
```

## 7、磁盘容量配额

本书在前面曾经讲到，Linux系统的设计初衷就是让许多人一起使用并执行各自的任务，从而成为多用户、多任务的操作系统。但是，硬件资源是固定且有限的，如果某些用户不断地在Linux系统上创建文件或者存放电影，硬盘空间总有一天会被占满。针对这种情况，root管理员就需要使用磁盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用的最大硬盘空间或最大文件个数，一旦达到这个最大值就不再允许继续使用。可以使用`quota`技术进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。`quota`技术还有软限制和硬限制的功能。

> **软限制**：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。
>
> **硬限制**：当达到硬限制时会提示用户，且强制终止用户的操作。

RHEL 8系统中已经安装了`quota`磁盘容量配额服务程序包，但存储设备却默认没有开启对`quota`技术的支持，此时需要手动编辑配置文件并重启一次系统，让系统中的启动目录（`/boot`）能够支持`quota`磁盘配额技术。

```bash
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                        /             xfs        defaults         1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b    /boot         xfs        defaults,uquota  1 2
/dev/mapper/rhel-swap                        swap          swap       defaults         0 0
/dev/cdrom                                   /media/cdrom  iso9660    defaults         0 0 
/dev/sdb1                                    /newFS        xfs        defaults         0 0 
/dev/sdb2                                    swap          swap       defaults         0 0 
[root@linuxprobe ~]# reboot
```

另外，对于学习过早期的Linux系统，或者具有RHEL 5/6系统使用经验的读者来说，这里需要特别注意。早期的Linux系统要想让硬盘设备支持`quota`磁盘容量配额服务，使用的是`usrquota`参数，而RHEL 7/8系统使用的则是`uquota`参数。在重启系统后使用`mount`命令查看，即可发现`/boot`目录已经支持`quota`磁盘配额技术了：

```bash
[root@linuxprobe ~]# mount | grep boot
/dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,usrquota)
```

接下来创建一个用于检查`quota`磁盘容量配额效果的用户`tom`，并针对`/boot`目录增加其他人的写权限，保证用户能够正常写入数据：

```bash
[root@linuxprobe ~]# useradd tom
[root@linuxprobe ~]# chmod -R o+w /boot
```

`xfs_quota`命令用于管理设备的磁盘容量配额，语法格式为“`xfs_quota [参数] 配额 文件系统`”。

这是一个专门针对`XFS`文件系统来管理quota磁盘容量配额服务而设计的命令。其中，-c参数用于以参数的形式设置要执行的命令；`-x`参数是专家模式，让运维人员能够对`quota`服务进行更多复杂的配置。接下来使用`xfs_quota`命令来设置用户`tom`对`/boot`目录的`quota`磁盘容量配额。具体的限额控制包括：硬盘使用量的软限制和硬限制分别为3MB和6MB；创建文件数量的软限制和硬限制分别为3个和6个。

```bash
[root@linuxprobe ~]# xfs_quota -x -c 'limit bsoft=3m bhard=6m isoft=3 ihard=6 tom' /boot
[root@linuxprobe ~]# xfs_quota -x -c report /boot
User quota on /boot (/dev/sda1)
                               Blocks                     
User ID          Used       Soft       Hard    Warn/Grace     
---------- -------------------------------------------------- 
root           114964          0          0     00 [--------]
tom                 0       3072       6144     00 [--------]
```

上面所使用的参数分为两组，分别是`isoft/ihard`与`bsoft/bhard`，下面深入讲解一下。在上面中曾经讲过，在Linux系统中每个文件都会使用一个独立的`inode`信息块来保存属性信息，一个文件对应一个`inode`信息块，所以`isoft`和`ihard`就是通过限制系统最大使用的inode个数来限制了文件数量。`bsoft`和`bhard`则是代表文件所占用的`block`大小，也就是文件占用的最大容量的总统计。

`soft`是软限制，超过该限制后也只是将操作记录写到日志中，不对用户行为进行限制。而`hard`是硬限制，一旦超过系统就会马上禁止，用户再也不能创建或新占任何的硬盘容量。

当配置好上述各种软硬限制后，尝试切换到一个普通用户，然后分别尝试创建一个体积为5MB和8MB的文件。可以发现，在创建8MB的文件时受到了系统限制：

```bash
[root@linuxprobe ~]# su - tom
[tom@linuxprobe ~]$ cd /boot
[tom@linuxprobe boot]$ dd if=/dev/zero of=/boot/tom bs=5M count=1
1+0 records in
1+0 records out
5242880 bytes (5.2 MB, 5.0 MiB) copied, 0.00298178 s, 1.8 GB/s
[tom@linuxprobe boot]$ dd if=/dev/zero of=/boot/tom bs=8M count=1
dd: error writing '/boot/tom': Disk quota exceeded
1+0 records in
0+0 records out
4194304 bytes (4.2 MB, 4.0 MiB) copied, 0.00398607 s, 1.1 GB/s
```

`edquota`命令用于管理系统的磁盘配额，英文全称为“edit quota”，语法格式为“`edquota [参数] 用户名`”。

在为用户设置了`quota`磁盘容量配额限制后，可以使用`edquota`命令按需修改限额的数值。其中，`-u`参数表示要针对哪个用户进行设置；-g参数表示要针对哪个用户组进行设置。

`dquota`命令中可用的参数以及作用

| 参数 | 作用                        |
| ---- | --------------------------- |
| -u   | 对某个用户进行设置          |
| -g   | 对某个用户组进行设置        |
| -p   | 复制原有的规则到新的用户/组 |
| -t   | 限制宽限期限                |



`edquota`命令会调用`Vi`或`Vim`编辑器来让`root`管理员修改要限制的具体细节，记得用`wq`保存退出。下面把用户`tom`的硬盘使用量的硬限额从5MB提升到8MB：

```bash
[tom@linuxprobe ~]$ exit
[root@linuxprobe ~]# edquota -u tom
Disk quotas for user tom (uid 1001):
  Filesystem                   blocks       soft       hard     inodes     soft     hard
  /dev/sda1                      4096       3072       8192          1        3        6
[root@linuxprobe ~]# su - tom
[tom@linuxprobe ~]$ cd /boot
[tom@linuxprobe boot]$ dd if=/dev/zero of=/boot/tom bs=8M count=1
1+0 records in
1+0 records out
8388608 bytes (8.4 MB, 8.0 MiB) copied, 0.0185476 s, 452 MB/s
```

## 8、VDO虚拟数据优化

`VDO`（Virtual Data Optimize，虚拟数据优化）是一种通过压缩或删除存储设备上的数据来优化存储空间的技术。`VDO`是红帽公司收购了Permabit公司后获取的新技术，并与2019-2020年前后，多次在RHEL 7.5/7.6/7.7上进行测试，最终随RHEL 8系统正式公布。`VDO`技术的关键就是对硬盘内原有的数据进行删重操作，它有点类似于我们平时使用的网盘服务，在第一次正常上传文件时速度特别慢，在第二次上传相同的文件时仅作为一个数据指针，几乎可以达到“秒传”的效果，无须再多占用一份空间，也不用再漫长等待。除了删重操作，`VDO`技术还可以对日志和数据库进行自动压缩，进一步减少存储浪费的情况。VDO针对各种类型文件的压缩效果如下表所示。

| 文件名  | 描述                            | 类型              | 原始大小（KB） | 实际占用空间（KB） |
| ------- | ------------------------------- | ----------------- | -------------- | ------------------ |
| dickens | 狄更斯文集                      | 英文原文          | 9953           | 9948               |
| mozilla | Mozilla的1.0可执行文件          | 执行程序          | 50020          | 33228              |
| mr      | 医用resonanse图像               | 图片              | 9736           | 9272               |
| nci     | 结构化的化学数据库              | 数据库            | 32767          | 10168              |
| ooffice | Open Office.org 1.01 DLL        | 可执行程序        | 6008           | 5640               |
| osdb    | 基准测试用的MySQL格式示例数据库 | 数据库            | 9849           | 9824               |
| reymont | 瓦迪斯瓦夫·雷蒙特的书           | PDF               | 6471           | 6312               |
| samba   | samba源代码                     | src源码           | 21100          | 11768              |
| sao     | 星空数据                        | 天文格式的bin文件 | 7081           | 7036               |
| webster | 辞海                            | HTML              | 40487          | 40144              |
| xml     | XML文件                         | HTML              | 5220           | 2180               |
| x-ray   | 透视医学图片                    | 医院数据          | 8275           | 8260               |

`VDO`技术支持本地存储和远程存储，可以作为本地文件系统、`iSCSI`或`Ceph`存储下的附加存储层使用。红帽公司在VDO介绍页面中提到，在部署虚拟机或容器时，建议采用逻辑存储与物理存储为10∶1的比例进行配置，即1TB物理存储对应10TB逻辑存储；而部署对象存储时 （例如使用Ceph）则采用逻辑存储与物理存储为3∶1的比例进行配置，即使用1TB物理存储对应3TB逻辑存储。

简而言之，`VDO`技术能省空间！

有两种特殊情况需要提前讲一下。其一，公司服务器上已有的`dm-crypt`之类的技术是可以与`VDO`技术兼容的，但记得要先对卷进行加密再使用`VDO`。因为加密会使重复的数据变得有所不同，因此删重操作无法实现。要始终记得把加密层放到VDO之下，如图6-14所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/VDO.jpg)

其二，`VDO`技术不可叠加使用，1TB的物理存储提升成10TB的逻辑存储没问题，但是再用10TB翻成100TB就不行了。左脚踩右脚，真的没法飞起来。

通过上面的学习，相信同学们已经把对硬盘进行分区、格式化、挂载操作的方法拿捏得死死的了。我们把虚拟机关闭，添加一块容量为20GB的新`SATA`硬盘进来，开机后就能看到这块名称为`/dev/sdc`的新硬盘了：

```bash
[root@linuxprobe ~]# ls -l /dev/sdc
brw-rw----. 1 root disk 8, 32 Jan 6 22:26 /dev/sdc
```

RHEL/CentOS 8系统中默认已经启用了`VDO`技术。`VDO`技术现在是红帽公司自己的技术，兼容性自然没得说。如果您所用的系统没有安装`VDO`的话也不要着急，用`dnf`命令即可完成安装：

```bash
[root@linuxprobe ~]# dnf install kmod-kvdo vdo
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:01:56 ago on Wed 06 Jan 2021 10:37:19 PM CST.
Package kmod-kvdo-6.2.0.293-50.el8.x86_64 is already installed.
Package vdo-6.2.0.293-10.el8.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
```

首先，创建一个全新的`VDO`卷。

新添加进来的物理设备就是使用`vdo`命令来管理的，其中`name`参数代表新的设备卷的名称；`device`参数代表由哪块磁盘进行制作；`vdoLogicalSize`参数代表制作后的设备大小。依据红帽公司推荐的原则，20GB硬盘将翻成200GB的逻辑存储：

```bash
[root@linuxprobe ~]# vdo create --name=storage --device=/dev/sdc --vdoLogicalSize=200G
Creating VDO storage
Starting VDO storage
Starting compression on VDO storage
VDO instance 0 volume is ready at /dev/mapper/storage
```

> Linux命令行严格区别大小写，`vdoLogicalSize`参数中的L与S字母必须大写。

在创建成功后，使用`status`参数查看新建卷的概述信息：

```bash
[root@linuxprobe ~]# vdo status --name=storage
VDO status:
  Date: '2021-01-06 22:51:33+08:00'
  Node: linuxprobe.com
Kernel module:
  Loaded: true
  Name: kvdo
  Version information:
    kvdo version: 6.2.0.293
Configuration:
  File: /etc/vdoconf.yml
  Last modified: '2021-01-06 22:49:33'
VDOs:
  storage:
    Acknowledgement threads: 1
    Activate: enabled
    Bio rotation interval: 64
    Bio submission threads: 4
    Block map cache size: 128M
    Block map period: 16380
    Block size: 4096
    CPU-work threads: 2
    Compression: enabled
    Configured write policy: auto
    Deduplication: enabled
………………省略部分输出信息………………
```

有上可见，在输出信息中包含了`VDO`卷创建的时间、主机名、版本、是否压缩（Compression）及是否删重（Deduplication）等关键信息。

接下来，对新建卷进行格式化操作并挂载使用。

新建的`VDO`卷设备会被乖乖地存放在`/dev/mapper`目录下，并以设备名称命名，对它操作就行。另外，挂载前可以用`udevadm settl`e命令对设备进行一次刷新操作，避免刚才的配置没有生效：

```bash
[root@linuxprobe ~]# mkfs.xfs /dev/mapper/storage 
meta-data=/dev/mapper/storage    isize=512    agcount=4, agsize=13107200 blks
         =                       sectsz=4096  attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1
data     =                       bsize=4096   blocks=52428800, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=25600, version=2
         =                       sectsz=4096  sunit=1 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@linuxprobe ~]# udevadm settle
[root@linuxprobe ~]# mkdir /storage
[root@linuxprobe ~]# mount /dev/mapper/storage /storage
```

如果想查看设备的实际使用情况，使用`vdostats`命令即可。`human-readable`参数的作用是将存储容量自动进位，以人们更易读的方式输出（比如，显示20G而不是20971520K）：

```bash
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.0G     16.0G  20%           99%
```

这里显示的`Size`是实际物理存储的空间大小（即20.0GB是硬盘的大小），如果想看逻辑存储空间，可以使用`df`命令进行查看：

```bash
[root@linuxprobe ~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M  9.6M  974M   1% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
/dev/sda1             1014M  152M  863M  15% /boot
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sdb1              2.0G   47M  2.0G   3% /newFS
/dev/mapper/storage    200G  2.4G  198G   2% /storage
```

随便复制一个大文件过来，看看占用了多少容量，以及空间节省率（Space saving）是多少：

```bash
[root@linuxprobe ~]# ls -lh /media/cdrom/images/install.img 
-r--r--r--. 1 root root 448M Apr 4 2019 /media/cdrom/images/install.img
[root@linuxprobe ~]# cp /media/cdrom/images/install.img /storage/
[root@linuxprobe ~]# ls -lh /storage/install.img 
-r--r--r--. 1 root root 448M Jan  6 23:06 /storage/install.img
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.4G     15.6G  22%           18%
```

效果不明显，再复制一份相同的文件过来，看看这次占用了多少空间：

```bash
[root@linuxprobe ~]# cp /media/cdrom/images/install.img /storage/rhel.img
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.5G     15.5G  22%           55%
```

是不是感觉很棒？！原先448MB的文件这次只占用了不到100MB的容量，空间节省率也从18%提升到了55%。当然这还仅仅是两次操作而已，好处就已经如此明显了。

最后，将设备设置成永久挂载生效，一直提供服务。

`VDO`设备卷在创建后会一直存在，但需要手动编辑`/etc/fstab`文件后才能在下一次重启后自动挂载生效，为我们所用。对于这种逻辑存储设备，其实不太建议使用`/dev/mapper/storage`作为设备名进行挂载。不如试试前面所说的`UUID`吧：

```bash
[root@linuxprobe ~]# blkid /dev/mapper/storage 
/dev/mapper/storage: UUID="cd4e9f12-e16a-415c-ae76-8de069076713" TYPE="xfs"
```

打开`/etc/fstab`文件，把对应的字段填写完整。建议再加上`_netdev`参数，表示等系统及网络都启动后再挂载`VDO`设备卷，以保证万无一失。

```bash
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                        /             xfs        defaults           1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b    /boot         xfs        defaults,uquota    1 2
/dev/mapper/rhel-swap                        swap          swap       defaults           0 0
/dev/cdrom                                   /media/cdrom  iso9660    defaults           0 0 
/dev/sdb1                                    /newFS        xfs        defaults           0 0 
/dev/sdb2                                    swap          swap       defaults           0 0 
UUID=cd4e9f12-e16a-415c-ae76-8de069076713    /storage      xfs        defaults,_netdev   0 0 
```

## 9、软硬方式链接

在引领大家学习完本章所有的硬盘管理知识之后，刘遄老师终于可以放心大胆地讲解Linux系统中的“快捷方式”了。在Windows系统中，快捷方式就是指向原始文件的一个链接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方，会导致链接文件失效。但是，这个看似简单的东西在Linux系统中可不太一样。

Linux系统中存在软链接和硬链接两种不同的类型。

**软链接（soft link）：**也叫符号链接（symbolic link），仅仅包含所链接文件的名称和路径，很像一个记录地址的标签。当原始文件被删除或移动后，新的链接文件也会随之失效，不能被访问。可以针对文件、目录设置软链接，跨文件系统进行链接也不是问题。从这一点来看，它与Windows系统的“快捷方式”具有一样的性质。用户访问软链接的效果如图6-15所示。

**硬链接（hard link）：**可以将它理解为一个“指向原始文件`block`的指针”，系统会创建出一个与原来一模一样的`inode`信息块。所以，硬链接文件与原始文件其实是一模一样的，只是名字不同。每添加一个硬链接，该文件的`inode`个数就会增加1；而且只有当该文件的`inode`个数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件`block`的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，不能跨分区对目录文件进行硬链接。用户访问硬链接的效果如图6-16所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E8%BD%AF%E9%93%BE%E6%8E%A5.jpg)

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/%E7%A1%AC%E9%93%BE%E6%8E%A5.jpg)

大家翻开手头这本书的目录页，看一下目录标题和对应的页码就应该能够理解了。链接文件就是指向实际内容所在位置的一个标签，通过这个标签，可以找到对应的数据。

`ln`命令用于创建文件的软硬链接，英文全称为“link”，语法格式为“`ln [参数]原始文件名 链接文件名`”。

`ln`命令的可用参数以及作用如下表所示。在使用`ln`命令时，是否添加`-s`参数，将创建出性质不同的两种“快捷方式”。因此如果没有扎实的理论知识和实践经验做铺垫，尽管能够成功完成实验，但永远不会明白为什么会成功。

ln命令中可用的参数以及作用

| 参数 | 作用                                               |
| ---- | -------------------------------------------------- |
| -s   | 创建“符号链接”（如果不带-s参数，则默认创建硬链接） |
| -f   | 强制创建文件或目录的链接                           |
| -i   | 覆盖前先询问                                       |
| -v   | 显示创建链接的过程                                 |

为了更好地理解软链接、硬链接的不同性质，我们先创建出一个文件，为其创建一个软链接：

```bash
[root@linuxprobe ~]# echo "Welcome to linuxprobe.com" > old.txt
[root@linuxprobe ~]# ln -s old.txt new.txt
[root@linuxprobe ~]# cat old.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat new.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l old.txt 
-rw-r--r-- 1 root root 26 Jan 11 00:08 old.txt
```

原始文件名为`old`，新的软链接文件名为`new`。删掉原始文件后，软链接文件立刻就无法读取了：

```bash
[root@linuxprobe ~]# rm -f old.txt 
[root@linuxprobe ~]# cat new.txt 
cat: readit.txt: No such file or directory
```

接下来针对原始文件`old`创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建了一个指针。这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会因为原始文件的删除而导致无法读取了。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了2。

```bash
[root@linuxprobe ~]# echo "Welcome to linuxprobe.com" > old.txt
[root@linuxprobe ~]# ln old.txt new.txt
[root@linuxprobe ~]# cat old.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat new.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l old.txt 
-rw-r--r-- 2 root root 26 Jan 11 00:13 old.txt
```

这是一个非常有意思的现象。创建的硬链接文件竟然会让文件属性第二列的数字变成了2，这个数字表示的是文件的inode信息块的数量。相信同学们已经非常肯定地知道，即便删除了原始文件，新的文件也会一如既往地可以读取，因为只有当文件`inode`数量被“清零”时，才真正代表这个文件被删除了。

```bash
[root@linuxprobe ~]# rm -f old.txt 
[root@linuxprobe ~]# cat new.txt 
Welcome to linuxprobe.com
```

## 10、课后习题

1．/home目录与/root目录内存放的文件有何相同点以及不同点？

**答：**这两个目录都是用来存放用户家目录数据的，但是，/root目录存放的是root管理员的家目录数据。

2．假如一个设备的文件名称为/dev/sdb，可以确认它是主板第二个插槽上的设备吗？

**答：**不一定，因为设备的文件名称是由系统的识别顺序来决定的。

3．如果硬盘中需要5个分区，则至少需要几个逻辑分区？

**答：**可以选用创建3个主分区+1个扩展分区的方法，然后把扩展分区再分成2个逻辑分区，即有了5个分区。

4．/dev/sda5是主分区还是逻辑分区？

**答：**逻辑分区。

5．哪个服务决定了设备在/dev目录中的名称？

**答：**udev设备管理器服务。

6．用一句话来描述挂载操作。

**答：**当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”。

7．在配置quota磁盘容量配额服务时，软限制数值必须小于硬限制数值么？

**答：**不一定，软限制数值可以小于等于硬限制数值。

8．VDO技术能够提升硬盘的物理存储空间么？

**答：**不可以，VDO是通过压缩或删重操作来提高硬盘的逻辑空间大小。

9．若原始文件被改名，那么之前创建的硬链接还能访问到这个原始文件么？

**答：**可以。

